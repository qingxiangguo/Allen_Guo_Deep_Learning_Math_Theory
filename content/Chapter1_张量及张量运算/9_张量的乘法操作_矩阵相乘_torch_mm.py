# _*_ coding=utf-8 _*_
# torch.mm,处理二维矩阵的乘法（与仅仅元素对应乘法不一样），而且也只能处理二维矩阵，其他维度要用torch.matmul，不支持广播！！！
# 矩阵相乘有torch.mm和torch.matmul两个函数。其中前一个是针对二维矩阵，后一个是高维。当torch.mm用于大于二维时将报错
# 注意，一定要意识到，矩阵相乘和元素相乘完全不一样，如何判断两个矩阵可以相乘呢（使用mm和matmul）
# 当矩阵A的列数（column）等于矩阵B的行数（row）时，A与B可以相乘。矩阵C的行数等于矩阵A的行数，C的列数等于B的列数。
# 乘积C的第m行第n列的元素等于矩阵A的第m行的元素与矩阵B的第n列对应元素【乘积之和】。
import torch

a = torch.tensor([[1, 3],
                 [2, 3]])

b = torch.tensor([[2, 4],
                 [1, 5]])

print('torch.mm result = ', torch.mm(a, b))
print('torch.mul result = ', torch.mul(a, b))

'''
# 矩阵相乘有点绕人，诀窍就是，生成数组的第一行时，先第一个矩阵取第一行，然后与第二个数组的列（一，二列）求点积，求完后，第一个矩阵取第二行，然后与第二个数组的第一列求积
# 矩阵相乘一般不满足交换律，除非两个一模一样的矩阵
torch.mm result =  tensor([[ 5, 19],  # 生成2 X 2的矩阵，第一行是，1*2 + 3* 1 = 5， 1*4 + 3*5 = 19， 第二行，2*2 + 3* 1 = 7，2*4 + 3*5 = 23 
        [ 7, 23]])
        
torch.mul result =  tensor([[ 2, 12],  # 每个元素对应相乘，比较好理解
        [ 2, 15]])
'''

